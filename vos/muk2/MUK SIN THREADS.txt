MINIX AS A UNIKERNEL (MUK) SIN THREADS 
=======================================


http://man7.org/linux/man-pages/man3/insque.3.html
http://man7.org/linux/man-pages/man3/SLIST_HEAD.3.html

https://www.geeksforgeeks.org/g-fact22-concept-of-setjump-and-longjump/
https://publications.gbdirect.co.uk/c_book/chapter9/nonlocal_jumps.html

       The functions described on this page are used for performing
       "nonlocal gotos": transferring execution from one function to a
       predetermined location in another function.

La idea es implementar un scheduler que invoque a funciones 

main ()
{
	main_init();
	while(true) {
		next_funct = get_from_queue(); // obtiene la proxima funcion a ejecutar de una cola de funciones.
		if( next_funct == NULL)
			mnx_receive(ANY, msg);
		else
			next_funct();
	}
}

Como se implementaria un servidor tipico
========================================
	
server (where)
{
	goto where; 
	svr_init();
	while( TRUE){
		rcode = receive(ANY, &msg);
to_switch:
		switch(msg.type){
			case SERVICE1:
				rcode = call_service1();
				break;
			case SERVICE2:
				rcode = call_service2();
				break;				
		}
to_send:
		rcode = send(msg.source, rply_msg);
to_receive:
	}
}	

Las funciones bloqueantes son las de IPC.
	Por lo tanto, supongamos receive(ANY, &msg)
	
	sender = search(p_list);
	if( sender == NULL) 
		// no hay mensajes
	else {
		server->p_rts_flags = RECEIVING;
		server->p_getfrom   = ANY;
		server->p_mptr		= &msg;
		return();
	}
	
	
receive()
{
	buscar en la cola del proceso si hay alguien queriendo envier
		si hay alguien	
			es el que espero?
				si, copiar el mensaje, poner en cola al sender, cambiarle los flags
				no, setear los flags, sacar de cola al receiver, return()
							
}
	
linked list 
https://www.includehelp.com/ds/implementation-of-priority-queue-using-linked-list.aspx

fijarse tambien en MINIX4RT


QUE HACER CUANDO UN PROCESO INTERNO SE COMUNICA CON UN EXTERNO.
Como el INTERNO se puede bloquear, debe crear un thread para esperar.


Se podria realizar el mismo tratamiento que con interrupciones.
Es decir. tener un thread por cada endpoint que recibe o envia mensajes
y cuando recibe un mensaje, pone una marca en el descriptor del proceso (similar al notify)
y activa el proceso.

CADA PROCESO deberia armarce como bloques. Supongamos


MINIX AS A UNIKERNEL (MUK) SIN THREADS 
=======================================

La idea es implementar un scheduler que invoque a funciones 

main ()
{
	main_init();
	while(true) {
		next_funct = get_from_queue(); // obtiene la proxima funcion a ejecutar de una cola de funciones.
		if( next_funct == NULL)
			mnx_receive(ANY, msg);
		else
			next_funct();
	}
}

Como se implementaria un servidor tipico
========================================
	
server (where)
{
	goto where; 
	svr_init();
	while( TRUE){
		rcode = receive(ANY, &msg);
to_switch:
		switch(msg.type){
			case SERVICE1:
				rcode = call_service1();
				break;
			case SERVICE2:
				rcode = call_service2();
				break;				
		}
to_send:
		rcode = send(msg.source, rply_msg);
to_receive:
	}
}	

Las funciones bloqueantes son las de IPC.
	Por lo tanto, supongamos receive(ANY, &msg)
	
	sender = search(p_list);
	if( sender == NULL) 
		// no hay mensajes
	else {
		server->p_rts_flags = RECEIVING;
		server->p_getfrom   = ANY;
		server->p_mptr		= &msg;
		return();
	}
	
	
receive()
{
	buscar en la cola del proceso si hay alguien queriendo envier
		si hay alguien	
			es el que espero?
				si, copiar el mensaje, poner en cola al sender, cambiarle los flags
				no, setear los flags, sacar de cola al receiver, return()
							
}
	
linked list 
https://www.includehelp.com/ds/implementation-of-priority-queue-using-linked-list.aspx
https://linux.die.net/man/3/queue

fijarse tambien en MINIX4RT

QUE HACER CUANDO UN PROCESO INTERNO SE COMUNICA CON UN EXTERNO.
Como el INTERNO se puede bloquear, debe crear un thread para esperar.


Se podria realizar el mismo tratamiento que con interrupciones.
Es decir. tener un thread por cada endpoint que recibe o envia mensajes
y cuando recibe un mensaje, pone una marca en el descriptor del proceso (similar al notify)
y activa el proceso.

CADA PROCESO deberia armarce como bloques. Supongamos

=====================================================================================================
20190914:
	cree un programa de prueba muk2.c 
	
SECUENCIA DE EJECUCION DE CLIENT 

	root@node0:/usr/src/dvs/vos/muk2# ./muk2 | grep client
	 muk2.c:init_client:97:
	 muk2.c:init_client:110:nr=1 endp=1 flags=0 misc=0 name=CLIENT
	 muk2.c:muk_client:170:
	 muk2.c:muk_client:177:stop 1
	 muk2.c:muk_client:179:stop 1a
	 muk2.c:muk_client:182:return 1
	 muk2.c:muk_client:179:stop 1a
	 muk2.c:muk_client:187:stop 2
	 muk2.c:muk_client:189:stop 2a
	 muk2.c:muk_client:192:return 2
	 muk2.c:muk_client:189:stop 2a
	 muk2.c:muk_client:197:stop 3
	 muk2.c:muk_client:199:stop 3a
	 muk2.c:muk_client:202:return 3
	 muk2.c:muk_client:199:stop 3a
	 muk2.c:muk_client:177:stop 1
	 muk2.c:muk_client:179:stop 1a
	 muk2.c:muk_client:182:return 1
	 muk2.c:muk_client:179:stop 1a
	 muk2.c:muk_client:187:stop 2
	 muk2.c:muk_client:189:stop 2a
	 muk2.c:muk_client:192:return 2
	 muk2.c:muk_client:189:stop 2a
	 muk2.c:muk_client:197:stop 3
	 muk2.c:muk_client:199:stop 3a
	 muk2.c:muk_client:202:return 3
	 muk2.c:muk_client:199:stop 3a
	 muk2.c:muk_client:177:stop 1
	 muk2.c:muk_client:179:stop 1a
	 muk2.c:muk_client:182:return 1


SECUENCIA DE EJECUCION DEL SERVER 
root@node0:/usr/src/dvs/vos/muk2# ./muk2 | grep server
 muk2.c:init_server:75:
 muk2.c:init_server:87:nr=0 endp=0 flags=0 misc=0 name=SERVER
 muk2.c:muk_server:121:
 muk2.c:muk_server:128:stop 1
 muk2.c:muk_server:130:stop 1a
 muk2.c:muk_server:133:return 1
 muk2.c:muk_server:130:stop 1a
 muk2.c:muk_server:138:stop 2
 muk2.c:muk_server:140:stop 2a
 muk2.c:muk_server:143:return 2
 muk2.c:muk_server:140:stop 2a
 muk2.c:muk_server:148:stop 3
 muk2.c:muk_server:150:stop 3a
 muk2.c:muk_server:153:return 3
 muk2.c:muk_server:150:stop 3a
 muk2.c:muk_server:128:stop 1
 muk2.c:muk_server:130:stop 1a
 muk2.c:muk_server:133:return 1
 muk2.c:muk_server:130:stop 1a
 muk2.c:muk_server:138:stop 2
 muk2.c:muk_server:140:stop 2a
 muk2.c:muk_server:143:return 2
 muk2.c:muk_server:140:stop 2a
 muk2.c:muk_server:148:stop 3
 muk2.c:muk_server:150:stop 3a
 muk2.c:muk_server:153:return 3
 muk2.c:muk_server:150:stop 3a
 muk2.c:muk_server:128:stop 1
 muk2.c:muk_server:130:stop 1a
 muk2.c:muk_server:133:return 1
 muk2.c:muk_server:130:stop 1a

 
DESPUES DE MOFICADO EL CODIGO

root@node0:/usr/src/dvs/vos/muk2# ./muk2 
 muk2.c:init_main:142:
 muk2.c:init_server:153:
 muk2.c:init_server:165:nr=0 flags=0 misc=0 name=SERVER
 muk2.c:init_client:175:
 muk2.c:init_client:188:nr=1 flags=0 misc=0 name=CLIENT
 muk2.c:muk_sched:299:stage=0
 muk2.c:muk_client:243:stage=0
MUK2_RETURN: muk2.c:muk_client:246: rcode=2
 muk2.c:pick_proc:285:
 muk2.c:pick_proc:288:p_nr=0
 muk2.c:muk_sched:305:current_nr=0
 muk2.c:muk_sched:314:before longjmp current_nr=0
ViolaciÃ³n de segmento


=====================================================================================================
20190915:
		SE BAJA LA LIBRERIA libtask 
		
=====================================================================================================
20190917:	ya compilo PM, RDISK y SYSTASK 
		Faltan compilar las librerias syslib, mollib 
		
=====================================================================================================
20190919:		
		Se implmento muk_sendrec 

	
=====================================================================================================
20190922:	 SYSTASK+RDISK+PM 

=====================================================================================================
20190924:	 SYSTASK+RDISK+PM+FS+IS+NWEB+FTP 

=====================================================================================================
20190925:	
		Se convirtieron todas las librerias de .so a  .a (estaticas)

		Se adaptaron M3NWEB y WIS para que use los sockets como usa tcpproxy.c 

=====================================================================================================
20190928:	NO FUNCIONAN CORRECTAMENTE NI WIS NI M3NWEB

	WIS: Cada peticion crea una nueva tarea y funciona perfecto.
	Probando WIS ANDAN TODOS 
	    
	Se convirtieron todas las librerias de .so a  .a (estaticas) en MUK !!!
			

=====================================================================================================
20190929:	
			NO FUNCIONA EL M3NWEB 
			LA IMAGEN DE DISKETTE PARECE ESTAR CORRECTA COMPROBADA CON fuse-mfs
			
			SOLUCION: CREAR UNA TASK NUEVA POR CADA PETICION  TAL COMO LO HACE EL ftpproxy.c DE EJEMPLO DE LIBTASK 
				RESPUESTA: NO SE PUEDE PORQUE CADA TAREA REQUIRE BINDEARSE PARA PODER COMUNICARSE CON FS 
							EL BIND NO SOLO SE HACE CONTRA EL MUK SINO TAMBIEN CONTRA SYSTASK Y PM 
							
			FUNCIONO M3NWEB Y  WIS PERFECTAMENTE
			
			El problema era que en los MUK_vcopy() se estaba utilizando SELF.
			

			
ULTIMO_LOG 		
=====================================================================================================

TODO: 			Adaptar a LIBTASK para que incluya sendrec y m3ipc para comunicaciones externas
				Quizas se puede crear un hilo 
							hilo {
								Escucha por DVK el pedido (dvk_receive)
								notifica a la tarea (muk_notify)
								espera la respuesta( muk_receive)
								envia la respuesta al cliente (dvk_send)
							}
				RESPUESTA: NO FUNCIONARIA PORQUE EL HILO ESTA FUERA DEL CONTROL DE LIBTASK POR LO QUE SE PUEDEN
						PRODUCIR CONDICIONES DE COMPETENCIA. NO PODRIA USAR LAS FUNCIONES muk_receive, muk_xxxx 
							
				SOLUCION:
						DVK_receive_T(src_ep, msg, timeout){
							do {
								rcode = dvk_receive_T(ANY, msg, TIMOUT_NOWAIT);
								if( rcode == EDVSTIMEDOUT) {
									if( timeout > 0) {
										timeout -= MUK_DVK_INTERVAL;
										taskdelay((MUK_DVK_INTERVAL);
									}
								}
							}while(rcode != EDVSTIMEDOUT);
				
				
TODO:  ADAPTAR M3FTP PARA QUE ESCUCHE POR DVK (al cliente) Y OPERE SOBRE MUK 

ERROR:	DE VEZ EN CUANDO SE CUELGA EL M3NWEB
		 m3nweb.c:nweb_server:256:total_bytes=103730
		 m3nweb.c:main_nweb:333:Conection accept
		./muk2.sh: lÃ­nea 6:  6732 ViolaciÃ³n de segmento  ./muk2 muk.cfg

ERROR:	ANDA MAL EL REGISTRO DE TIEMPOS 
		t_start=796533.00 t_stop=693299.00 t_total=-103234.00
		total_bytes = 103730
		Throuhput = -1.004805 [bytes/s]
		t_start=860439.00 t_stop=665281.00 t_total=-195158.00
		total_bytes = 103730
		Throuhput = -0.531518 [bytes/s]
		t_start=344936.00 t_stop=164486.00 t_total=-180450.00
		total_bytes = 103730
		Throuhput = -0.574841 [bytes/s]
		t_start=549012.00 t_stop=375500.00 t_total=-173512.00
		total_bytes = 103730
		Throuhput = -0.597826 [bytes/s]
		t_start=684145.00 t_stop=637770.00 t_total=-46375.00
		total_bytes = 103730
		Throuhput = -2.236765 [bytes/s]
		t_start=639695.00 t_stop=535057.00 t_total=-104638.00
		total_bytes = 0
		t_start=-nan t_stop=508960.00 t_total=226458.00
		total_bytes = 103730
		Throuhput = 0.458054 [bytes/s]
		t_start=-nan t_stop=513242.00 t_total=3794.00
		total_bytes = 0
		t_start=-nan t_stop=326901.00 t_total=-472027.00
		total_bytes = 0
		t_start=179644.00 t_stop=119667.00 t_total=-59977.00
		total_bytes = 103730
		Throuhput = -1.729496 [bytes/s]
		t_start=119930.00 t_stop=951194.00 t_total=831264.00
		total_bytes = 0
		t_start=-nan t_stop=951985.00 t_total=572299.00
		total_bytes = 0

TODO:	PROBAR MUK con la libreria convertidas

TODO: 	PROBAR CREAR EN MUK UN THREAD PARA wis_server A VER SI TRABAJA MERJOR 

ATENCION: libtask brinda funciones propias para sustituir PRINTF y otras
		utilizar estas funciones en lugar de las estandar sobre todo en DEBUG y MACROS 
		NO PARECEN SER USADAS ??



TODO: Se podria hacer una consola externa para controlar ciertas cosas en forma similar a UML
		por ejemplo agregando al IS un nuevo servidor que se llame con_server que estaria 
		escuchando en algun socket UDP, para que sea remotizable.
		luego, un comando externo haria 
					# muk2cmd	<command>
					<command>:
							help 
							dc
							sys_proc
							rd 
							pm_proc
							fs_proc
							fs_super
							

Ver makefile de  https://github.com/jbleners/Falcon


Se podria hacer una especie de whatdog.
Cada Tarea tiene un contador que se va decrementando una vez por segundo si no ha tenido actividad.
Cuando hay actividad (en el receive, por ejemplo) vuelve el contador a su valor inicial.
Para el caso del web server que espera en el socket, entonces no deberia implementarse.
para ello habria que poner un MISC-FLAG que indique que se quiere controlar si esta dormido.


Hacer lo siguiente:
	Desarrollar una tarea que funcione similar al clock que utilize los timers ya definidos en MINIX 
	para implementar los TIMEOUTs de SEND, SENDREC, RECEIVE, WAIT4BIND 

	enqueue_alarm(taskrunning, 1000);
	While(TRUE){
		do {
			next_deadline = dequeue_alarm(&task);
			taskdelay(next_deadline);
			enqueue_alarm(taskrunning, 1000);
		} while ( task == taskrunning);
		wakeup(task);
	}	
	
PROBLEMA DE TIMEOUTS:
		1) Cuando una IPC temporizada recibe o envia un mensaje antes del vencimiento del timeout
			debe remover el timeout de la lista.
		2) Hacer que timeout_task haga ciclos de 1000 ms no es garantia de que esos tiempos sean precisos
			porque <----1000--->ejecutan otros procesos<-----1000----> 
			y esto contabilizaria como 2000 ms, cuando en realidad fueron mucho mas.
			Se debería tener una fuente de tiempo mas precisa u obtener el tiempo restante.
		
	
	
		

		
		
		



	
	
	










	


